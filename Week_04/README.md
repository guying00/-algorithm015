学习笔记

            第四周总结
    1、本周学习的内容是深度优先搜索、广度优先搜索、贪心算法和二分查找。
    深度优先与广度优先的区别，深度优先是先朝同一个方向搜索，直到不能搜索后，返回然后转向下一个方向；
    广度优先是先搜索周围紧邻的，直到搜索完毕近前的节点，再向较远的地方搜索。
    深度优先搜索一般使用递归来实现，广度优先搜索一般使用迭代来实现，在用于图的处理时，两种方法都需要使用访问数组来标记已访问节点，
    避免重复处理同一节点导致时间复杂度升高，甚至出现死循环；
    
    贪心算法是在逻辑上，简单的基于当前能够获取到的信息，做出当前最优的一种选择，然后在此基础上，继续处理问题的其余部分，直到问题
    处理完成，它不保存过去状态，不回溯，所以其适用场景比较窄，只在一些满足贪心条件的场合适用，有时也可以使用贪心算法来粗略的估计
    问题的最优解可能的一个范围；
    
    二分查找的使用有3个前提：1、单调性，2、存在上下界，3、数据可以通过索引访问；它的实现就是不同的确定要找的数据在整个数据集中的
    上下界，直到上下界之间只能放下一个数据元素位置，此时查找结束，并确定目标数据的存在性；在查找的过程中，若要找的数据刚好落在
    我们处理的边界上，查找可能提前结束；
    
    2、代码编写时，bfs和dfs的中止判断条件，一定要放到处理函数的开头，可以简化代码。
    
    3、在学习方法上，五毒神掌是进行专业训练的好方法，在实际应用时，尤其是开始时，一定要摒弃旧有的凡事想自己搞定的坏习惯，
    一定要记住，我们是在学习别人的优秀成果，核心：第一是学习、第二是学习、第三还是学习，只有学有所获，才能在提高自己解决问题的能力。
    
    4、使用二分查找，寻找一个半有序数组 [4, 5, 6, 7, 0, 1, 2] 中间无序的地方。
    此问题与寻找旋转排序数组中的最小值 https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/ 处理逻辑基本相同，
    处理方式是：每次获取mid值后，将其值与前一个元素和后一个元素比较，如果出现逆序，我们就找到了断点，若没有逆序，我们基于其值，
    确定数据的左右半部分那边是有序的，断点必然出现在无序的一部分。
    
    func findMin(nums []int) int {
        left, right := 0, len(nums) - 1
        mid := (left+right) / 2
        for left <= right {
            if mid > 0 && nums[mid-1] > nums[mid] {
                return nums[mid]
            }
            if mid < len(nums)-1 && nums[mid] > nums[mid+1] {
                return nums[mid+1]
            }
            //数组左半部份有序
            if nums[0] <= nums[mid]  {
                //目标值在左半部份
                left = mid+1
            } else {  //数组右半部份有序
                //目标值在左半部份
                right = mid-1
            }
            mid = (left+right) / 2
        }
        return nums[0]
    }
    
    只需将要找的目标确定为最小值的索引即可；
    func findMinIdx(nums []int) int {
        left, right := 0, len(nums) - 1
        mid := (left+right) / 2
        for left <= right {
            if mid > 0 && nums[mid-1] > nums[mid] {
                return mid
            }
            if mid < len(nums)-1 && nums[mid] > nums[mid+1] {
                return mid+1
            }
            //数组左半部份有序
            if nums[0] <= nums[mid]  {
                //目标值在左半部份
                left = mid+1
            } else {  //数组右半部份有序
                //目标值在左半部份
                right = mid-1
            }
            mid = (left+right) / 2
        }
        return 0
    }