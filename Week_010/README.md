学习笔记

            毕业总结
    一、数据结构
        1、基础数据结构
        数组：结构上就是一段连续的内存地址，实现简单，通过下标对随机访问数组元素提供O(1)的时间复杂度支持，但对数据的插入和删除不友好，
          尤其是在数组靠前的部分插入和删除数据，将需要对插入点之后的大量数据进行移位处理，代价高昂；
    
        链表：通过定义带内存指针的节点结构，将离散的内存数据组织为一条长链结构，通过定义head和tail指针，支持O(1)时间复杂度的插入和
        删除，但对链表中间节点的访问需要从head节点逐个向后查找，是一个O(n)时间的操作；
    
        跳表：一种基于链表之上，用于加速链表查找和访问速度的数据结构。它要求链表中的数据必须有序，在此条件下，通过建立多层链表，上层的
          链表跳过下层链表的某些节点，直接指向下层链表的中间节点，从而建立一个类似索引的结构，可在O(log n)时间完成数据的查找，
          同时占用内存空间会增加，插入和删除数据的时间也会有相应的增加。其实现思想体现为通过提升维度解决问题的思路，同时也表现为
          用空间换时间；
          
        栈：规则很简单，数据后进先出，但应用场景广泛，著名的例子如汉诺塔，只支持对栈顶数据进行操作，一些变种，如最小栈可提供
        栈顶元素以外的额外信息，添加、删除时间复杂度皆为O(1)；
        
        队列：规则也很简单，数据先进先出，在需要对数据进行排队处理的场合大量使用，添加、删除时间复杂度皆为O(1)；
    
        优先队列：队列的一个变种，其数据不再是按实际先进先出，而是按一定规则对数据排序，将满足最优先条件的数据先出队处理，
        一般用堆来实现，具有O(log n)时间复杂度的插入元素性能，O(n)的初始化构造的时间复杂度；
        
        双端队列：即在队列的首尾都可以进行相同的插入删除数据操作的队列，实现上一般采用环形结构处理，具有O(1)时间复杂度的插入和
        删除性能。
        
        2、高级数据结构
        哈希表、集合和映射：哈希表是通过hash函数实现键值映射，从而实现类似数组下标直接访问数据的效果，在插入、删除和查找数据，
        都可以实现O(1)的分摊处理时间。集合和映射都是基于哈希表来实现的上层数据结构，封装了底层数组和hash函数的处理，提供抽象
        的编程接口便于使用，集合是用于存储一堆无序数据的数据，实现O(1)时间的随机访问，映射广泛使用在键值存储和查找的场合；
    
        图、树、二叉树和二叉搜索树：图是一种二维数据结构，由定点和边组成，有多种划分方式，有向图和无向图，连通图和非连通图，
        有权图和无权图等，表示一个图的方法一般有两种：邻接矩阵和邻接链表。树可以理解为一种特化的图，如果一个连通有向图，其中无环路，
        只有一个顶点的入度为0，其就是一颗以入度为0的顶点为根的树，对树的定义一般采用递归结构，通过定义父节点和子节点关系来表达一棵树。
        二叉树是每个节点最多只有左右两个子节点的树，有很多分类，二叉搜索树就是其中一种，二叉搜索树是满足以下条件，根节点的值
        大于左子树中节点的值而小于右子树中节点的值，同时，其左右子树也满足相同条件；
    
        堆和二叉堆：堆是一种可以在O(1)时间内查找一堆数据中的最大值或最小值的数据结构，实现有很多中，最简单的实现方式就是基于数组和
        完全二叉树的二叉堆，由于完全二叉树的特征，可以直接用使用下标计算来确定某一节点的父节点和子节点在数组中的下标索引，可以简单
        表示一个完全二叉树的结构，二叉堆有大顶堆和小顶堆，对大顶堆，任何节点的值的都大于等于其子节点，保证最大的数据位于堆顶，
        即堆数组中索引为0的元素；
        
    二、算法
        1、递归、分治和回溯
        递归是在设计分治和回溯算法是的一种用于分解分析问题的有效方式，也是实现分治和回溯的一种
        方便快速，易于理解的编程方法。分治算法是将问题分解为若干相同或相似子问题，知道子问题简单到可以直接求解，然后再用子问题的解
        合并生成原问题的解的方法；分解的方式就是不停寻找最近最间的重复子问题，例如在处理k个数字组合问题时，可以将问题分解为1个数字
        和k-1个数字组合的问题；回溯算法是在一些问题没有明显简单的分解规律，不得不用暴力枚举的方式时，用于解决问题的一种方法，
        尤其适用于约束补偿问题，它保存整个枚举过程的状态，并在枚举过程中进行判断，若当前解不能满足约数要求，则放弃当前解
        并不再搜索其子解，直接回溯到之前的处理状态并继续下一次搜索，典型的如N皇后问题；
        
        2、搜索算法
        深度优先与广度优先的区别，深度优先是先朝同一个方向搜索，直到不能搜索后，返回然后转向下一个方向；
        广度优先是先搜索周围紧邻的，直到搜索完毕近前的节点，再向较远的地方搜索。
        深度优先搜索一般使用递归来实现，广度优先搜索一般使用迭代来实现，在用于图的处理时，两种方法都需要使用访问数组来标记已访问节点，
        避免重复处理同一节点导致时间复杂度升高，甚至出现死循环；
        
        贪心算法是在逻辑上，简单的基于当前能够获取到的信息，做出当前最优的一种选择，然后在此基础上，继续处理问题的其余部分，直到问题
        处理完成，它不保存过去状态，不回溯，所以其适用场景比较窄，只在一些满足贪心条件的场合适用，有时也可以使用贪心算法来粗略的估计
        问题的最优解可能的一个范围；
        
        二分查找的使用有3个前提：1、单调性，2、存在上下界，3、数据可以通过索引访问；它的实现就是不同的确定要找的数据在整个数据集中的
        上下界，直到上下界之间只能放下一个数据元素位置，此时查找结束，并确定目标数据的存在性；在查找的过程中，若要找的数据刚好落在
        我们处理的边界上，查找可能提前结束；
        
        3、动态规划
        其英文解释为: "Simplifying a complicated problem by breaking it down into simpler sub-problems"，
        意思是通过不停的将复杂问题分解为更为简单的子问题，从而简化其处理；动态规划与分治的区别在于有无最优子结构，
        最优子结构的意义在于，是否能够通过子问题的最优解构造出当前问题的最优解，若能，则问题存在最优子结构，
        这也是进行问题分解的思路和原则，
        问题分解的方法有两种常用方法：1、减少问题中的元素个数，2、按不同的条件分解问题；
        方法1的方式比较简单，一般直接用递归或迭代的方式，即可有效缩小问题规模，最终到达问题的简单边界求解；
        方法2则复杂一些，需要考虑不同的条件是否有相互重叠或冲突的可能，在组合不同条件子问题获得的最优解来构造当前问题的最优解时，
        尤其需要注意。高级动态规划则多为第2中，问题由多个维度的子问题叠加而成，所以问题状态需要分解到不同的维度上，
        即二维甚至三维的规划状态，由于状态空间维度提升会造成运行时间指数级增长，在处理时需要尽早淘汰次优解，压缩状态空间来加快处理，
        同时维度的升高意味着转移方程更加复杂多变，需要更强的数学处理能力和逻辑思维能力才能掌控
        
    三、特殊数据结构和算法
        字典树、并查集、高级搜索(剪枝、双向BFS、启发式搜索)、AVL树和红黑树。
        字典树：优点是最大限度地减少无谓的字符串比较，查询效率比哈希表高，典型应用是用于统计和排序大量的字符串（但不仅限于字符串），
        所以经常被搜索引擎系统用于文本词频统计，
        它有如下性质：1. 结点本身不存完整单词；2. 从根结点到某一结点，路径上经过的字符连接起来，为该结点对应的字符串；3. 每个结点的所有子结点路径代表的字符都不相同；
        
        并查集适用于组团、配对问题、集合分组等场合；它有3个基本操作：
        makeSet(s)：建立一个新的并查集，其中包含 s 个单元素集合。
        unionSet(x, y)：把元素 x 和元素 y 所在的集合合并，要求 x 和 y 所在的集合不相交，如果相交则不合并。
        find(x)：找到元素 x 所在的集合的代表，该操作也可以用于判断两个元素是否位于同一个集合，只要将它们各自的代表比较一下就可以了。
        
        高级搜索技巧包括了剪枝、双向BFS、启发式搜索：
        其中剪枝是在处理问题解空间的过程中，对于已经明确不能满足要求的解，不再沿搜索树向下搜索，而是提前返回不再处理这些不满足要求的解，
        从而降低问题时间复杂度，提高处理速度的方法；
        双向BFS是用来降低空间复杂度的方法，此技巧的应用基于这样一个事实，对于图类应用，单向
        BFS随着处理深度的增加，需要缓存的节点数往往呈指数增长，所以在开始节点和中止节点都确定的时候，从首尾两端同时开始搜索，以两个BFS
        相遇作为结束条件，能够显著降低空间复杂度，并能提供处理速度(处理的节点少很多)；
        启发式搜索则是根据一定的条件，判断哪些搜索方向可能更快更好的到达目标，找到满足条件或最优的解，从而控制搜索方向，降低处理复杂度。
        
        AVL树是一种平衡二叉树，它利用平衡因子来控制树的平衡(左子树的高度减去它的右子树的高度（有时相反）), balance factor = {-1, 0, 1}，
        当树中有节点的平衡因子不在上述范围时，它通过4种旋转操作来重新平衡树：1. 左旋、2. 右旋、3. 左右旋、4. 右左旋；由于限制条件严格，
        其树的维护成本比较高，并且由于需要在每个节点存储平衡因子，其空间占用也相对较大；
        
        红黑树是一种近似平衡的二叉搜索树，它能够确保任何一个结点的左右子树的高度差小于两倍。
        具体来说，红黑树是满足如下条件的二叉搜索树，其满足如下条件：
        每个结点要么是红色，要么是黑色
        根结点是黑色
        每个叶结点（NIL结点，空结点）是黑色的。
        不能有相邻接的两个红色结点
        从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。
        红黑树的关键性质是：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。
        
        Bloom Filter使用 HashTable + 拉链存储重复元素，
        一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索
        一个元素是否在一个集合中。
        优点是空间效率和查询时间都远远超过一般的算法，
        缺点是有一定的误识别率和删除困难。
        
        LRU Cache主要特点如下
        两个要素： 大小 、替换策略
        Hash Table + Double LinkedList
        O(1) 查询
        O(1) 修改、更新
    
    四、位运算、排序和字符串算法
        1、本周学习的内容是位运算、布隆过滤器、LRU缓存和排序算法；
        位运算技巧主要有如下：
        异或：相同为 0，不同为 1。也可用“不进位加法”来理解。
        XOR - 异或
        异或操作的一些特点：
        x ^ 0 = x
        x ^ 1s = ~x // 注意 1s = ~0
        x ^ (~x) = 1s
        x ^ x = 0
        c = a ^ b => a ^ c = b, b ^ c = a // 交换两个数
        a ^ b ^ c = a ^ (b ^ c) = (a ^ b) ^ c // associative
        
        指定位置的位运算
        1. 将 x 最右边的 n 位清零：x & (~0 << n)
        2. 获取 x 的第 n 位值（0 或者 1）： (x >> n) & 1
        
        3. 获取 x 的第 n 位的幂值：x & (1 << n)
        4. 仅将第 n 位置为 1：x | (1 << n)
        5. 仅将第 n 位置为 0：x & (~ (1 << n))
        6. 将 x 最高位至第 n 位（含）清零：x & ((1 << n) - 1)
        
        实战位运算要点
        • 判断奇偶：
        x % 2 == 1 —> (x & 1) == 1
        x % 2 == 0 —> (x & 1) == 0
        • x >> 1 —> x / 2.
        即： x = x / 2; —> x = x >> 1;
        mid = (left + right) / 2; —> mid = (left + right) >> 1;
        • X = X & (X-1) 清零最低位的 1
        • X & -X => 得到最低位的 1
        • X & ~X => 0
        
        2、排序算法
        1. 比较类排序：
        通过比较来决定元素间的相对次序，由于其时间复杂度不能突破
        O(nlogn)，因此也称为非线性时间比较类排序。
        2. 非比较类排序：
        不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时
        间下界，以线性时间运行，因此也称为线性时间非比较类排序。
        3、字符串算法，字符串在大多数语言中都以字符数组的形式储存，有的语言实现是可变有的不可变，所以其涉及到的处理算法也大多是对数组元素的各种访问和处理，其中一些基础的处理就是字符串遍历、字符串比较、大小写转换、字符统计、字符替换等，还有数字字符串转和其表示数值的相互转换、字母异位词、回文串等一些常见的处理；更高级的字符串算法有求字符串的子串、子序列和字符串的匹配等，这些往往需要用到递归、动态规划等高级算法才能有效处理；而字符串匹配算法主要有暴力处理、KMP、Rabin-Karp、BoyerMoore、Sunday算法。
        从效率上讲，暴力处理 < Rabin-Karp < KMP < BoyerMoore < Sunday；
        其中BoyerMoore算法由于要同时处理坏字符表和好后缀表，代码会比较繁琐，Sunday算法只需要建立一个字符位移表，既高效又简单。
    
    五、解题和编码思路
        有一个基本的思路，就是分解问题，大事化小，由简单独立的情况入手分析，然后推广组合出最终问题的解，同时，尽量利用
    在处理过程中已经产生或获取到了的有用信息，帮助后续问题的解决，可以有效降低处理问题的时间和空间复杂度；
        对于代码编写，在理清楚处理逻辑前，最好不要随意乱敲代码，因为变量和参数的设计，对最终代码的清晰度，可读性，时空复杂度以及性能，
    都会有很大的影响，所以在实际实现前，先想清楚，输入是什么，输出是什么，在处理过程中有哪些信息需要保存，在函数调用过程中，
    有哪些信息需要传递，如何利用缓存等，变量和参数设计好后，再着手实现具体逻辑，能够事半功倍。
    